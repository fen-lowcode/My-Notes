
Intelâ€™s x86 architecture originated as a **16-bit architecture**. From this origin, the terminology reflects the historical word sizes: a **word** refers to a 16-bit quantity, a **double word** to 32 bits, and a **quad word** to 64 bits. These terms are important when reading assembly instructions and understanding how data is stored in memory.

In **x86-64 systems**, C primitive types map to these Intel data representations. The standard `int` type occupies a **double word (4 bytes)**. Pointers, for instance `char *`, occupy **quad words (8 bytes)**, consistent with the 64-bit address space. The `long` type is also implemented as a **64-bit quad word**, allowing a much wider range of integer values than `int`.

The mapping of C types to Intel types, assembly suffixes, and sizes is as follows: `char` is a **byte** (1 byte) with assembly suffix `b`, `short` is a **word** (2 bytes) with suffix `w`, `int` is a **double word** (4 bytes) with suffix `l`, `long` and pointers (`char *`) are **quad words** (8 bytes) with suffix `q`. Floating-point types follow a similar pattern: `float` is **single-precision (4 bytes)** with suffix `s`, while `double` is **double-precision (8 bytes)** with suffix `l`.

The x86-64 instruction set provides instructions that correspond to each data size. Data movement operations, for example, exist in four variants: `movb` for bytes, `movw` for words, `movl` for double words, and `movq` for quad words. The suffix `l` is used both for 4-byte integers and 8-byte double-precision floating-point numbers, but this does not cause ambiguity because floating-point operations use a **completely separate set of registers and instructions**.

Historically, x86 processors used a special **80-bit (10-byte) floating-point format** for all floating-point operations. In C, this corresponds to the `long double` type. This type is not recommended for general use because it is **non-portable across platforms** and usually does not have the same hardware support for high-speed calculations as single- and double-precision floating-point operations.

Understanding these mappings is critical when reading assembly code generated by compilers such as GCC, particularly when inspecting registers and operand sizes. It also explains why memory alignment, pointer sizes, and register usage vary between types, and why suffixes in assembly instructions indicate operand size rather than the underlying type directly.

| C Declaration | Intel Data Type  | Assembly-Code Suffix | Size (bytes) |
| ------------- | ---------------- | -------------------- | ------------ |
| char          | Byte             | b                    | 1            |
| short         | Word             | w                    | 2            |
| int           | Double word      | l                    | 4            |
| long          | Quad word        | q                    | 8            |
| char *        | Quad word        | q                    | 8            |
| float         | Single precision | s                    | 4            |
| double        | Double precision | l                    | 8            |
